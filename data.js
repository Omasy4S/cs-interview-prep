// @ts-nocheck
// ============================================================================
// КОНФИГУРАЦИЯ И ДАННЫЕ
// ============================================================================

// Метаданные вкладок: используются для hero-блоков и навигации
const tabsConfig = [
    {
        id: 'oop',
        title: 'ООП',
        hero: 'ООП без скуки',
        eyebrow: 'TypeScript · Архитектура',
        description: 'Разбираем четыре столпа объектно-ориентированного подхода на живых примерах и тренируемся применять их в реальном коде.'
    },
    {
        id: 'algorithms',
        title: 'Алгоритмы',
        hero: 'Алгоритмическая интуция',
        eyebrow: 'Patterns · Big-O',
        description: 'Собираем коллекцию паттернов (два указателя, скользящее окно, рекурсия), чтобы быстро выбирать правильный алгоритм на интервью.'
    },
    {
        id: 'data-structures',
        title: 'Структуры данных',
        hero: 'Дизайн памяти',
        eyebrow: 'Stacks · Trees · Maps',
        description: 'Учимся выбирать структуры под ограничения продукта: скорость доступа, стоимость вставки и контроль памяти.'
    },
    {
        id: 'leetcode',
        title: 'LeetCode',
        hero: 'Паттерны задач',
        eyebrow: 'Practice · Insights',
        description: 'От Two Sum до графов: закрепляем устойчивые подходы, чтобы распознавать задачу по нескольким признакам.'
    },
    {
        id: 'event-loop',
        title: 'Event Loop',
        hero: 'Асинхронность = UX',
        eyebrow: 'Runtime · JS',
        description: 'Понимаем, как движок JS распределяет задачи, чтобы строить отзывчивый интерфейс без «фризов».'
    },
    {
        id: 'solid',
        title: 'SOLID',
        hero: 'Принципы без мантр',
        eyebrow: 'Clean Architecture',
        description: 'Смотрим на SOLID как на язык договоренностей в команде: когда разделять классы и как защищаться от регрессий.'
    },
    {
        id: 'foundations',
        title: 'Основы',
        hero: 'Системное мышление',
        eyebrow: 'Cohesion · Coupling',
        description: 'Повторяем фундаментальные идеи о связанности, слоях и сложностях, чтобы принимать архитектурные решения осознанно.'
    },
    {
        id: 'theory',
        title: 'Теория',
        hero: 'Библиотека инсайтов',
        eyebrow: 'Mindset · Leadership',
        description: 'Собрание коротких эссе про мышление инженера: от CAP до Observability и работы с ИИ.'
    }
];

const AppConfig = {
    tabs: tabsConfig,
    theory: {
        global: null, // инициализируем ниже после объявления массива
        byTab: null   // инициализируем после объявления theoryLibrary
    }
};

const tabMetaMap = AppConfig.tabs.reduce((acc, tab) => {
    acc[tab.id] = tab;
    return acc;
}, {});

const globalTheoryInsights = [
    {
        type: 'info',
        icon: 'fa-compass',
        title: 'Стратегия подготовки к собеседованиям',
        tagline: 'Focus > хаотичный гринд',
        summary: 'Раздели подготовку на волны: теория → практика → симуляции. Каждая волна завершается конкретным deliverable (конспект, набор решённых задач, mock-interview).',
        bullets: [
            'Определи «мишень»: какие роли и стек нужны. Это отсечёт лишние темы.',
            'Составь недельные слоты: 2× алгоритмы, 1× системный дизайн, 1× проект.',
            'Каждый понедельник фиксируй инсайт недели — что изменишь в подходе.'
        ],
        why: 'Без системы подготовка превращается в марафон без финиша.',
        how: 'Держи Kanban: backlog тем, in progress, done. После каждой сессии обновляй карточки и заметки.',
        takeaway: 'Стратегия побеждает количество: важен прогресс по целям, а не счёт задач.'
    },
    {
        type: 'info',
        icon: 'fa-brain',
        title: 'Ментальные модели для дебага',
        tagline: 'От симптома к гипотезе',
        summary: 'Рассматривай баг как гипотезу о нарушенном инварианте, а не как случайность.',
        bullets: [
            'Фиксируй ожидаемое состояние перед дебагом: это экономит время на «что должно быть».',
            'Собирай факты, прежде чем править — логи, метрики, последовательность действий.',
            'Каждый баг = новый чек в листе мониторинга.'
        ],
        why: 'Скорость фиксов зависит от того, как быстро ты находишь «узел» причины.',
        how: 'Используй цикл: гипотеза → эксперимент → вывод. Документируй, чтобы команда училась вместе.',
        takeaway: 'Дебаг — это исследование системы, а не угадайка.'
    },
    {
        type: 'info',
        icon: 'fa-lightbulb',
        title: 'Product thinking для разработчика',
        tagline: 'Пиши код с пониманием ценности',
        summary: 'Каждая фича — это гипотеза про метрики. Задача инженера — знать, какую метрику защищает его решение.',
        bullets: [
            'Всегда спрашивай «как мы узнаем, что это сработало?»',
            'Описывай фичу через пользовательский сценарий, а не только API.',
            'Фиксируй ограничения: SLA, платформы, доступность.'
        ],
        why: 'Код без контекста быстро превращается в техдолг.',
        how: 'Перед задачей напиши mini-brief: проблема → аудитория → успех.',
        takeaway: 'Product thinking = способность объяснить, зачем существует твоя фича.'
    },
    {
        type: 'info',
        icon: 'fa-rocket',
        title: 'Системы обучения и рост инженера',
        tagline: 'Постоянная кривая развития',
        summary: 'Рост = deliberate practice. Запланируй циклы: выбери навык → зафиксируй уровень → создай упражнение → ищи фидбек.',
        bullets: [
            'Держи журнал боли: баги, ревью, задачи, где не хватило знаний.',
            'Каждому навыку ставь KPI: «хочу за 30 минут объяснить Monorepo setup новичку».',
            'Построй peer-группу: обмен экспериментами ускоряет рост.'
        ],
        why: 'Без системы обучения карьерный рост случайен.',
        how: 'Раз в квартал пересматривай карту навыков и планируй следующий фокус.',
        takeaway: 'Инженер растёт не от лет стажа, а от осознанных циклов обучения.'
    },
    {
        type: 'info',
        icon: 'fa-book-open-reader',
        title: 'Чтение чужого кода',
        tagline: 'Учимся по живым системам',
        summary: 'Самый быстрый способ расти — читать код людей, которые сильнее тебя, и пытаться переписать его проще.',
        bullets: [
            'Ищи не «идеальный» код, а устойчивые решения в боевых сервисах.',
            'Всегда задавай себе вопрос: «почему это написано именно так?» и выписывай гипотезы.',
            'Пытайся переписать кусок короче — если теряется смысл, значит оригинал был не случайным.'
        ],
        why: 'Чтение кода прокачивает архитектурное чутьё и даёт реальные паттерны, а не учебные примеры.',
        how: 'Заведи «читательский дневник кода»: ссылки, вырезки и короткие комментарии, что тебя удивило.',
        takeaway: 'Чужой код — это бесплатный ментор, если относиться к нему как к учебнику.'
    },
    {
        type: 'info',
        icon: 'fa-people-arrows',
        title: 'Код-ревью без токсичности',
        tagline: 'Feedback как инструмент роста',
        summary: 'Хорошее ревью улучшает систему и отношения в команде, а не самоутверждает ревьюера.',
        bullets: [
            'Сначала спроси про контекст: ограничения, дедлайны, компромиссы.',
            'Комментируй последствия: «так будет сложнее протестировать», а не «это плохой код».',
            'Предлагай варианты: показывай альтернативу, а не только проблему.'
        ],
        why: 'Тон ревью напрямую влияет на скорость доставки и желание людей брать сложные задачи.',
        how: 'Используй формат: «наблюдение → риск → предложение». Например: «этот if дублируется, это риск расхождения логики, давай вынесем в helper».',
        takeaway: 'Ревью — это разговор о рисках и архитектуре, а не соревнование в умности.'
    },
    {
        type: 'info',
        icon: 'fa-recycle',
        title: 'Работа с legacy-кодом',
        tagline: 'Рефакторинг без героизма',
        summary: 'Legacy — это код без контекста. Сначала восстанови контекст, потом трогай строки.',
        bullets: [
            'Добавляй тесты вокруг поведения, которое боишься сломать.',
            'Фиксируй предположения в комментариях к коммитам и ADR: зачем ты меняешь этот участок.',
            'Рефакторь по шагам: сперва сделать код наблюдаемым, потом безопасным, и только потом красивым.'
        ],
        why: 'Большая часть времени уходит не на новый код, а на эволюцию старого.',
        how: 'Не переписывай всё с нуля. Выделяй seam-ы (границы), через которые можно постепенно вытеснять старую реализацию.',
        takeaway: 'Сильный инженер умеет жить с legacy и уменьшать его, а не только писать «с нуля».'
    }
];

const theoryLibrary = {
    oop: [
        {
            icon: 'fa-shield-halved',
            title: 'Инварианты через инкапсуляцию',
            tagline: 'State as a contract',
            summary: 'Инкапсуляция — это не про private-поля, а про гарантии того, что объект не перейдёт в недопустимое состояние.',
            code: `class Account {
    #balance = 0;
    deposit(amount) {
        if (amount <= 0) throw new Error('only positive');
        this.#balance += amount;
    }
    getBalance() {
        return this.#balance;
    }
}`,
            bullets: [
                'Инвариант: баланс не уходит в минус и меняется только через методы.',
                'Ошибки ловятся в одном месте, а не распределяются по коду.'
            ],
            why: 'Защищённые инварианты позволяют строить высокоуровневые сценарии без страха «сломать» объект.',
            how: 'Всегда формулируй, что объект гарантирует внешнему миру, и закрывай прямой доступ к состоянию.',
            takeaway: 'Инкапсуляция = контроль правил, а не просто приватность.'
        },
        {
            icon: 'fa-code-branch',
            title: 'Полиморфизм как расширяемость',
            tagline: 'Поведение по контракту',
            summary: 'Полиморфизм нужен, чтобы добавлять сценарии без изменения существующего кода.',
            code: `interface NotificationChannel {
    send(message: string): void;
}
class EmailChannel implements NotificationChannel {
    send(message) { console.log('Email', message); }
}
class SlackChannel implements NotificationChannel {
    send(message) { console.log('Slack', message); }
}
class IncidentNotifier {
    constructor(private channel: NotificationChannel) {}
    fire(message) { this.channel.send(message); }
}`,
            bullets: [
                'Бизнес-комбинаторика растёт быстрее, чем код — нужна точка расширения.',
                'Контракты упрощают тесты: подставил фейковый канал и проверил сценарий.'
            ],
            why: 'Новые каналы коммуникации появляются чаще, чем рефакторится ядро системы.',
            how: 'Описывай ожидаемое поведение интерфейсом и внедряй зависимости через конструктор.',
            takeaway: 'Полиморфизм — это про устойчивость к изменениям, а не про красивую иерархию.'
        },
        {
            icon: 'fa-sitemap',
            title: 'Наследование: когда использовать, когда избегать',
            tagline: 'Composition over inheritance',
            summary: 'Наследование создаёт жёсткую связь между классами. Часто лучше использовать композицию для большей гибкости.',
            code: `// Плохо: наследование
class Car extends Vehicle {
    constructor() {
        super();
        this.engine = new Engine();
    }
}

// Лучше: композиция
class Car {
    constructor(private engine: Engine) {}
    start() { this.engine.start(); }
}`,
            bullets: [
                'Наследование подходит для "is-a" отношений (Car is a Vehicle).',
                'Композиция лучше для "has-a" отношений (Car has an Engine).',
                'Наследование усложняет тестирование и рефакторинг.'
            ],
            why: 'Жёсткая иерархия наследования приводит к хрупкому коду, где изменения в базовом классе ломают всё.',
            how: 'Спрашивай себя: "Это действительно is-a отношение?" Если нет — используй композицию.',
            takeaway: 'Наследование — мощный инструмент, но его переоценка приводит к проблемам масштабирования.'
        },
        {
            icon: 'fa-diamond',
            title: 'Абстракция: уровни детализации',
            tagline: 'Hide complexity, expose intent',
            summary: 'Абстракция позволяет работать с системой на нужном уровне детализации, скрывая ненужные детали.',
            code: `// Низкий уровень абстракции
function processPayment(cardNumber, expiry, cvv, amount) {
    // 50 строк валидации, шифрования, API вызовов...
}

// Высокий уровень абстракции
class PaymentService {
    async charge(amount: Money, card: Card): Promise<Result> {
        // Все детали скрыты внутри
    }
}`,
            bullets: [
                'Абстракция позволяет думать о задаче, а не о реализации.',
                'Хорошая абстракция устойчива к изменениям реализации.',
                'Плохая абстракция утекает детали реализации.'
            ],
            why: 'Без абстракции код становится нечитаемым и хрупким к изменениям.',
            how: 'Создавай интерфейсы, которые выражают намерения, а не технические детали.',
            takeaway: 'Абстракция — это про управление сложностью через правильный уровень детализации.'
        },
        {
            icon: 'fa-code',
            title: 'Интерфейсы vs абстрактные классы',
            tagline: 'Contracts for collaboration',
            summary: 'Интерфейсы определяют контракты поведения, абстрактные классы могут содержать общую реализацию.',
            code: `interface Logger {
    log(message: string): void;
    error(message: string): void;
}

abstract class BaseLogger implements Logger {
    abstract log(message: string): void;
    error(message: string): void {
        this.log(\`ERROR: \${message}\`);
    }
}`,
            bullets: [
                'Интерфейсы: чистые контракты, множественное наследование.',
                'Абстрактные классы: контракты + общая реализация.',
                'TypeScript позволяет implements несколько интерфейсов.'
            ],
            why: 'Разные инструменты для разных сценариев: интерфейсы для гибкости, абстрактные классы для повторного использования.',
            how: 'Используй интерфейсы для определения API, абстрактные классы для шаблонного поведения.',
            takeaway: 'Выбор между интерфейсом и абстрактным классом зависит от того, нужна ли общая реализация.'
        }
    ],
    algorithms: [
        {
            icon: 'fa-chart-line',
            title: 'Алгоритмические коридоры',
            tagline: 'Сложность vs ограничения',
            summary: 'Перед выбором алгоритма нужно назвать ограничения входа: до 10⁴ — линейный перебор, до 10⁶ — логарифмы, выше — потоковые техники.',
            bullets: [
                'Данные < 10⁴ — можно позволить себе O(n²) и не усложнять код.',
                'Диапазон 10⁶–10⁷ — только O(n log n) и продуманная память.'
            ],
            why: 'Инженеру приходится аргументировать, почему решение выдержит трафик продукта.',
            how: 'Всегда озвучивай «коридор» перед кодом и обсуждай trade-off памяти/времени.',
            takeaway: 'Сложность — это язык общения с бизнесом о масштабируемости.'
        },
        {
            icon: 'fa-road',
            title: 'Жадные против динамики',
            tagline: 'Выбор стратегии',
            summary: 'Жадные алгоритмы быстры, если можно доказать локальную оптимальность. ДП — когда нужно хранить прошлые решения.',
            code: `function minCoins(amount, coins) {
    const dp = Array(amount + 1).fill(Infinity);
    dp[0] = 0;
    for (const coin of coins) {
        for (let i = coin; i <= amount; i++) {
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
    }
    return dp[amount];
}`,
            bullets: [
                'Если решение зависит только от текущего выбора — жадный подход.',
                'Если важно помнить путь — применяй табличку (ДП).'
            ],
            why: 'Не бывает «универсального» алгоритма — нужно объяснять логику выбора.',
            how: 'Проверь контрпример: если жадный провалится хоть раз, бери ДП.',
            takeaway: 'Определяй структуру задачи до того, как писать код.'
        },
        {
            icon: 'fa-arrows-left-right',
            title: 'Паттерн: два указателя',
            tagline: 'Линейный обход вместо квадратичного',
            summary: 'Два указателя движутся навстречу или параллельно, решая задачи на отсортированных массивах или строках за один проход.',
            code: `function isPalindrome(s) {
    let left = 0, right = s.length - 1;
    while (left < right) {
        if (s[left] !== s[right]) return false;
        left++;
        right--;
    }
    return true;
}`,
            bullets: [
                'Используй для поиска пары элементов с заданным свойством.',
                'Отсортированные данные — часто подсказка на два указателя.'
            ],
            why: 'O(n) вместо O(n²) при переборе всех пар.',
            how: 'Определи инвариант: что означает позиция указателей на каждом шаге.',
            takeaway: 'Два указателя экономят квадратичные вложенные циклы.'
        },
        {
            icon: 'fa-window-maximize',
            title: 'Скользящее окно',
            tagline: 'Оптимизация подмассивов',
            summary: 'Окно фиксированного или изменяемого размера скользит по массиву, переиспользуя вычисления предыдущих шагов.',
            code: `function maxSumSubarray(arr, k) {
    let sum = 0, max = 0;
    for (let i = 0; i < k; i++) sum += arr[i];
    max = sum;
    for (let i = k; i < arr.length; i++) {
        sum += arr[i] - arr[i - k];
        max = Math.max(max, sum);
    }
    return max;
}`,
            bullets: [
                'Фиксированное окно: сумма/среднее k элементов.',
                'Изменяемое окно: подстрока без повторов, диапазон с условием.'
            ],
            why: 'Вместо пересчёта всего окна каждый раз — убираем уходящий элемент и добавляем входящий.',
            how: 'Поддерживай инвариант окна: сумма, Set уникальных, счётчик частот.',
            takeaway: 'Скользящее окно превращает O(n×k) в O(n).'
        },
        {
            icon: 'fa-divide',
            title: 'Разделяй и властвуй',
            tagline: 'Рекурсивное деление задачи',
            summary: 'Задача делится на независимые подзадачи, решения комбинируются. Классика: бинарный поиск, merge sort, quick sort.',
            code: `function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    return merge(left, right);
}`,
            bullets: [
                'Делим проблему пополам → рекурсивно решаем → объединяем результаты.',
                'T(n) = 2T(n/2) + O(n) дает O(n log n) для сортировок.'
            ],
            why: 'Эффективная стратегия для структурированных данных.',
            how: 'Найди способ комбинировать решения подзадач независимо.',
            takeaway: 'Разделяй и властвуй — база логарифмических алгоритмов.'
        },
        {
            icon: 'fa-layer-group',
            title: 'Динамическое программирование: bottom-up',
            tagline: 'Табуляция вместо рекурсии',
            summary: 'Заполняем таблицу от простых случаев к сложным, избегая повторных вычислений и переполнения стека.',
            code: `function fib(n) {
    const dp = [0, 1];
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}`,
            bullets: [
                'Bottom-up: итеративно строим таблицу, нет стека вызовов.',
                'Top-down (мемоизация): рекурсия + кеш, удобнее писать.'
            ],
            why: 'Избегаем экспоненциальных пересчётов одних и тех же подзадач.',
            how: 'Определи состояние dp[i], переход между состояниями, базовые случаи.',
            takeaway: 'ДП решает проблемы перекрывающихся подзадач.'
        },
        {
            icon: 'fa-project-diagram',
            title: 'Обход графов: BFS и DFS',
            tagline: 'Ширина vs глубина',
            summary: 'BFS исследует уровни слой за слоем (очередь), DFS идёт вглубь до конца (стек/рекурсия).',
            code: `function bfs(graph, start) {
    const queue = [start], visited = new Set([start]);
    while (queue.length) {
        const node = queue.shift();
        for (const neighbor of graph[node]) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
}`,
            bullets: [
                'BFS находит кратчайший путь в невзвешенных графах.',
                'DFS проще для рекурсивных задач: обнаружение циклов, топологическая сортировка.'
            ],
            why: 'Разные задачи требуют разного порядка обхода.',
            how: 'BFS — очередь, DFS — стек. Следи за visited, чтобы не зациклиться.',
            takeaway: 'Выбор BFS/DFS зависит от свойств графа и цели обхода.'
        }
    ],
    'data-structures': [
        {
            icon: 'fa-database',
            title: 'Структура = SLA операций',
            summary: 'Структура данных выбирается под конкретные гарантийные буквы (вставка, чтение, удаление).',
            bullets: [
                'Очередь — когда важна справедливость, стек — когда важна история.',
                'Хеши дают O(1) в среднем, но чувствительны к коллизиям.'
            ],
            why: 'Неверный выбор структуры становится бутылочным горлышком спустя месяцы.',
            how: 'Перед реализацией заполни таблицу операций: сколько раз в секунду, какая задержка допустима.',
            takeaway: 'Структура данных — архитектурное решение, а не деталь реализации.'
        },
        {
            icon: 'fa-tree',
            title: 'Когда нужны деревья',
            summary: 'Деревья выигрывают, когда нужно хранить частично упорядоченные данные и быстро искать диапазоны.',
            code: `class SegmentTree {
    constructor(nums) {
        this.size = nums.length;
        this.tree = Array(this.size * 2).fill(0);
        for (let i = 0; i < this.size; i++) this.tree[this.size + i] = nums[i];
        for (let i = this.size - 1; i > 0; i--) {
            this.tree[i] = this.tree[i * 2] + this.tree[i * 2 + 1];
        }
    }
}`,
            bullets: ['Сегментные деревья отвечают на запросы диапазонов за O(log n).'],
            why: 'Когда данных много и запросов ещё больше, линейный перебор становится непозволительно дорогим.',
            how: 'Разбивай задачу на блоки (узлы), где каждый блок хранит агрегат.',
            takeaway: 'Дерево — компромисс между массивом и хешом.'
        },
        {
            icon: 'fa-list',
            title: 'Массив vs Связный список',
            tagline: 'Память против гибкости',
            summary: 'Массив хранит данные непрерывно, список — через указатели. Выбор зависит от операций.',
            code: `// Массив: O(1) доступ, O(n) вставка в начало
const arr = [1, 2, 3];
arr[1]; // O(1)
arr.unshift(0); // O(n)

// Список: O(n) доступ, O(1) вставка в начало
class Node {
    constructor(val, next = null) {
        this.val = val;
        this.next = next;
    }
}`,
            bullets: [
                'Массив: доступ по индексу O(1), вставка в середину O(n).',
                'Список: вставка/удаление O(1) если есть указатель, доступ O(n).'
            ],
            why: 'Частые вставки в середину коллекции убивают производительность массива.',
            how: 'Профилируй реальную нагрузку: что чаще — чтение или модификация.',
            takeaway: 'Массивы для индексации, списки для частых вставок.'
        },
        {
            icon: 'fa-hashtag',
            title: 'Хеш-таблицы: коллизии и рост',
            tagline: 'O(1) с оговорками',
            summary: 'Map/Set дают O(1) в среднем, но зависят от хеш-функции и load factor.',
            code: `// Коллизии решаются цепочками или открытой адресацией
class HashMap {
    constructor() {
        this.size = 16;
        this.buckets = Array(this.size).fill(null).map(() => []);
    }
    hash(key) {
        return key.toString().split('').reduce((acc, c) => 
            acc + c.charCodeAt(0), 0) % this.size;
    }
    set(key, val) {
        const index = this.hash(key);
        this.buckets[index].push([key, val]);
    }
}`,
            bullets: [
                'Load factor > 0.75 → рехеширование с увеличением размера.',
                'Плохая хеш-функция → кластеризация, деградация до O(n).'
            ],
            why: 'Хеш-таблицы — основа кеширования и быстрого поиска.',
            how: 'Используй встроенные Map/Set вместо самописных, если нет специфики.',
            takeaway: 'O(1) гарантирован только при правильной реализации.'
        },
        {
            icon: 'fa-fire',
            title: 'Heap: приоритетная очередь',
            tagline: 'Всегда знаем минимум/максимум',
            summary: 'Min/Max heap поддерживает инвариант: родитель всегда меньше/больше детей.',
            code: `class MinHeap {
    constructor() { this.heap = []; }
    insert(val) {
        this.heap.push(val);
        this.bubbleUp(this.heap.length - 1);
    }
    bubbleUp(index) {
        while (index > 0) {
            const parent = Math.floor((index - 1) / 2);
            if (this.heap[parent] <= this.heap[index]) break;
            [this.heap[parent], this.heap[index]] = 
                [this.heap[index], this.heap[parent]];
            index = parent;
        }
    }
}`,
            bullets: [
                'Вставка и извлечение min/max за O(log n).',
                'Используется в алгоритме Дейкстры, планировщиках, топ-k задач.'
            ],
            why: 'Нужен постоянный доступ к экстремуму без полной сортировки.',
            how: 'Поддерживай инвариант после каждой операции через bubbleUp/Down.',
            takeaway: 'Heap = эффективный способ держать коллекцию частично упорядоченной.'
        },
        {
            icon: 'fa-network-wired',
            title: 'Граф: выбор представления',
            tagline: 'Список смежности vs матрица',
            summary: 'Список смежности экономит память для разреженных графов, матрица удобна для плотных.',
            code: `// Список: {A: [B,C], B: [A,D]} — O(V+E) памяти
const adjList = new Map();
adjList.set('A', ['B', 'C']);

// Матрица: [[0,1,1], [1,0,1], [1,1,0]] — O(V²) памяти
const adjMatrix = [
    [0, 1, 1],
    [1, 0, 1],
    [1, 1, 0]
];`,
            bullets: [
                'Список: итерация по соседям O(degree), проверка ребра O(degree).',
                'Матрица: итерация по соседям O(V), проверка ребра O(1).'
            ],
            why: 'Соцсети, дороги — разреженные. Полносвязные системы — плотные.',
            how: 'Если E << V², бери список. Если нужна быстрая проверка ребра — матрицу.',
            takeaway: 'Представление графа влияет на сложность всех алгоритмов.'
        },
        {
            icon: 'fa-spell-check',
            title: 'Trie: эффективность префиксов',
            tagline: 'Словарь с разделяемыми префиксами',
            summary: 'Trie хранит строки так, что общие начала занимают одну ветку, экономя память и время поиска.',
            code: `class TrieNode {
    constructor() {
        this.children = {};
        this.isEnd = false;
    }
}
class Trie {
    constructor() { this.root = new TrieNode(); }
    insert(word) {
        let node = this.root;
        for (const char of word) {
            if (!node.children[char]) 
                node.children[char] = new TrieNode();
            node = node.children[char];
        }
        node.isEnd = true;
    }
}`,
            bullets: [
                'Поиск, вставка, удаление за O(k), где k — длина строки.',
                'Автодополнение, проверка орфографии, IP-маршрутизация.'
            ],
            why: 'Словарь из миллиона слов, но поиск не зависит от размера словаря.',
            how: 'Каждый узел — символ, путь от корня — префикс.',
            takeaway: 'Trie превращает поиск по словарю в обход дерева.'
        }
    ],
    leetcode: [
        {
            icon: 'fa-list-check',
            title: 'Распознаём паттерн',
            summary: 'Любая задача на массивы сводится к 5 приёмам: два указателя, скользящее окно, префиксы, сортировка + merge, стеки.',
            bullets: ['Держи рядом таблицу «симптом → паттерн».', 'Вопрос про строки с ограничением k — почти всегда окно.'],
            why: 'На собеседовании побеждает тот, кто быстро узнаёт форму задачи.',
            how: 'После чтения условия отметь ключевые слова: «отсортировано», «k элементов», «подмассив» — это подсказки.',
            takeaway: 'Паттерн = сокращённый путь к решению.'
        },
        {
            icon: 'fa-repeat',
            title: 'Цикл обратной связи',
            summary: 'После каждого решения фиксируй, что можно автоматизировать: шаблон кода, тест, визуализация.',
            why: 'Так формируется долгосрочная память, а не просто счёт решённых задач.',
            how: 'Пиши короткий ADR: условие → найденный паттерн → в каком случае не сработает.',
            takeaway: 'LeetCode — это про скорость распознавания.'
        },
        {
            icon: 'fa-coins',
            title: 'Задачи на жадность',
            tagline: 'Локальный оптимум → глобальный',
            summary: 'Жадный алгоритм делает локально оптимальный выбор на каждом шаге. Работает не всегда — нужно доказательство.',
            code: `// Jump Game: можем ли достичь последнего индекса
function canJump(nums) {
    let maxReach = 0;
    for (let i = 0; i < nums.length; i++) {
        if (i > maxReach) return false;
        maxReach = Math.max(maxReach, i + nums[i]);
    }
    return true;
}`,
            bullets: [
                'Interval scheduling, activity selection — классика жадности.',
                'Если задача имеет матроидную структуру, жадность оптимальна.'
            ],
            why: 'Простота и скорость: O(n) вместо O(2ⁿ) перебора.',
            how: 'Проверь контрпример. Если нашёл — используй ДП.',
            takeaway: 'Жадность красива, но требует обоснования корректности.'
        },
        {
            icon: 'fa-th',
            title: 'Матричные обходы',
            tagline: 'DFS/BFS на сетке',
            summary: 'Задачи на матрицах решаются обходом с отслеживанием visited. Четыре направления, границы, препятствия.',
            code: `// Number of Islands
function numIslands(grid) {
    let count = 0;
    const dfs = (i, j) => {
        if (i < 0 || j < 0 || i >= grid.length || 
            j >= grid[0].length || grid[i][j] === '0') return;
        grid[i][j] = '0';
        dfs(i+1,j); dfs(i-1,j); dfs(i,j+1); dfs(i,j-1);
    };
    for (let i = 0; i < grid.length; i++)
        for (let j = 0; j < grid[0].length; j++)
            if (grid[i][j] === '1') { count++; dfs(i,j); }
    return count;
}`,
            bullets: [
                'Островки, заливка, кратчайший путь — все через обход.',
                'Используй сетку как visited или отдельную структуру.'
            ],
            why: 'Сетки — частый тип задач на собеседованиях.',
            how: 'Определи направления движения, проверяй границы, помечай посещённые.',
            takeaway: 'Матрица = граф, где соседи — смежные клетки.'
        },
        {
            icon: 'fa-arrows-split-up-and-left',
            title: 'Backtracking: исчерпывающий поиск',
            tagline: 'Перебор с откатом',
            summary: 'Строим решение по частям, откатываемся при невалидном пути. Комбинации, перестановки, судоку.',
            code: `// Permutations
function permute(nums) {
    const result = [];
    const backtrack = (path) => {
        if (path.length === nums.length) {
            result.push([...path]);
            return;
        }
        for (const num of nums) {
            if (path.includes(num)) continue;
            path.push(num);
            backtrack(path);
            path.pop(); // откат
        }
    };
    backtrack([]);
    return result;
}`,
            bullets: [
                'Используй для задач, где нужны все решения, а не оптимальное.',
                'Отсечения (pruning) ускоряют перебор.'
            ],
            why: 'Единственный способ для комбинаторных задач без явной формулы.',
            how: 'Стройте дерево решений: выбор → рекурсия → откат.',
            takeaway: 'Backtracking = DFS по пространству решений с откатами.'
        },
        {
            icon: 'fa-chart-simple',
            title: 'Префиксные суммы',
            tagline: 'Предвычисление диапазонов',
            summary: 'Считаем кумулятивные суммы, чтобы получать сумму диапазона [L,R] за O(1).',
            code: `// Range Sum Query
class NumArray {
    constructor(nums) {
        this.prefix = [0];
        for (let i = 0; i < nums.length; i++)
            this.prefix[i+1] = this.prefix[i] + nums[i];
    }
    sumRange(left, right) {
        return this.prefix[right+1] - this.prefix[left];
    }
}`,
            bullets: [
                'Работает для сумм, XOR, произведений — любых ассоциативных операций.',
                'Subarray sum equals K: prefix + hashmap.'
            ],
            why: 'Вместо O(n) на каждый запрос — O(1) после O(n) предобработки.',
            how: 'prefix[i] = сумма элементов [0..i-1]. Диапазон = разность префиксов.',
            takeaway: 'Префиксы превращают повторные запросы диапазонов в O(1).'
        }
    ],
    'event-loop': [
        {
            icon: 'fa-infinity',
            title: 'Очереди задач',
            tagline: 'UX как договор',
            summary: 'Event Loop гарантирует, что синхронный стек выполняется до конца, а потом берётся следующая задача.',
            code: `console.log('A');
setTimeout(() => console.log('B'), 0);
console.log('C');`,
            bullets: ['Микрозадачи выполняются перед следующей перерисовкой.', 'Длинные макрозадачи = лаг UI.'],
            why: 'Без понимания очередей легко «подвесить» интерфейс таймером на 200мс.',
            how: 'Дроби тяжёлые операции на чанки < 16мс, измеряй в Performance профайлере.',
            takeaway: 'Уважай Event Loop — и пользователи не увидят спиннеры.'
        },
        {
            icon: 'fa-wand-magic-sparkles',
            title: 'Async/await как синтаксический сахар',
            summary: 'Await просто раскладывает промис на then, который попадает в очередь микрозадач.',
            why: 'Ошибки возникают, когда ожидают синхронности от async-функций.',
            how: 'Всегда учитывай, что после await управление возвращается в цикл событий — обнови состояние до await.',
            takeaway: 'Async/await — удобочитаемость, но не отмена асинхронной модели.'
        },
        {
            icon: 'fa-layer-group',
            title: 'Макрозадачи vs микрозадачи',
            tagline: 'Приоритеты выполнения',
            summary: 'Микрозадачи (Promise, queueMicrotask) выполняются после текущей задачи, но до следующей макрозадачи.',
            code: `console.log('1');
setTimeout(() => console.log('2'), 0); // макро
Promise.resolve().then(() => console.log('3')); // микро
console.log('4');
// Вывод: 1, 4, 3, 2`,
            bullets: [
                'Макро: setTimeout, setInterval, I/O, UI rendering.',
                'Микро: Promise.then, queueMicrotask, MutationObserver.'
            ],
            why: 'Порядок выполнения влияет на обновление UI и гонки данных.',
            how: 'Стек → микрозадачи → рендеринг → следующая макрозадача.',
            takeaway: 'Микрозадачи приоритетнее макрозадач.'
        },
        {
            icon: 'fa-hourglass-half',
            title: 'Блокирующие операции',
            tagline: 'Враги отзывчивости',
            summary: 'Синхронные тяжёлые вычисления блокируют поток, замораживая UI. Решение: Web Workers, разбиение на части.',
            code: `// Плохо: блокирует UI
function heavyCompute() {
    for (let i = 0; i < 1e9; i++) {}
}

// Хорошо: разбиваем
async function chunkedCompute() {
    for (let i = 0; i < 1000; i++) {
        await new Promise(resolve => setTimeout(resolve, 0));
        // вычисления
    }
}`,
            bullets: [
                'Web Workers для CPU-интенсивных задач в отдельном потоке.',
                'requestIdleCallback для низкоприоритетных задач.'
            ],
            why: 'Заблокированный UI = потерянные пользователи.',
            how: 'Профилируй Performance, ищи долгие tasks > 50ms.',
            takeaway: 'Держи главный поток свободным для интерактивности.'
        },
        {
            icon: 'fa-circle-notch',
            title: 'RequestAnimationFrame',
            tagline: 'Синхронизация с рендерингом',
            summary: 'rAF вызывается перед перерисовкой (~60 FPS). Идеален для анимаций и визуальных обновлений.',
            code: `let start;
function animate(timestamp) {
    if (!start) start = timestamp;
    const progress = timestamp - start;
    element.style.transform = \`translateX(\${progress}px)\`;
    if (progress < 1000) 
        requestAnimationFrame(animate);
}
requestAnimationFrame(animate);`,
            bullets: [
                'Браузер оптимизирует: пропускает кадры в неактивных вкладках.',
                'Не используй setTimeout для анимаций — будет дёрганье.'
            ],
            why: 'Плавность анимаций = качество UX.',
            how: 'Все DOM-манипуляции для анимации — через rAF.',
            takeaway: 'rAF = синхронизация с частотой обновления экрана.'
        }
    ],
    solid: [
        {
            icon: 'fa-layer-group',
            title: 'SRP как контроль причин изменений',
            summary: 'Класс должен меняться по одной причине. Иначе релиз превращается в серийные регрессии.',
            bullets: ['Fix-ы бродят между классами, когда в них смешаны обязанности.', 'SRP = дешёвые тесты и простая замена.'],
            why: 'В продуктовой разработке требования меняются быстрее, чем пишется код.',
            how: 'На ревью задавай вопрос: «что вынудит изменить этот модуль?» — если причин >1, дели ответственность.',
            takeaway: 'SRP — это про устойчивость рефакторинга.'
        },
        {
            icon: 'fa-plug-circle-bolt',
            title: 'DIP и тестируемость',
            summary: 'Инфраструктурные детали (HTTP, хранилище, email) должны зависеть от абстракций, иначе сервисы невозможно тестировать.',
            code: `class BillingService {
    constructor(private payment: PaymentGateway) {}
    async charge(order) {
        await this.payment.pay(order.total);
    }
}`,
            why: 'Нам нужно уметь подменять зависимости без переписывания ядра.',
            how: 'Зависимости передаются извне (inversion) и мокируются на тестах.',
            takeaway: 'DIP — фундамент для конфигурируемой архитектуры.'
        },
        {
            icon: 'fa-door-open',
            title: 'Open/Closed Principle',
            tagline: 'Открыт для расширения, закрыт для модификации',
            summary: 'Добавление новой функциональности не должно требовать изменения существующего кода.',
            code: `// Плохо: при добавлении нового типа нужно менять discount
function discount(customer) {
    if (customer.type === 'regular') return 0;
    if (customer.type === 'premium') return 0.1;
    if (customer.type === 'vip') return 0.2;
}

// Хорошо: новые типы добавляются без изменений
interface Customer {
    getDiscount(): number;
}
class PremiumCustomer implements Customer {
    getDiscount() { return 0.1; }
}`,
            bullets: [
                'Используй полиморфизм, стратегии, декораторы.',
                'Закрытие через абстракции: интерфейсы и базовые классы.'
            ],
            why: 'Изменение работающего кода рискует внести баги.',
            how: 'Выделяй точки расширения через интерфейсы до появления второго варианта.',
            takeaway: 'OCP делает систему устойчивой к изменениям требований.'
        },
        {
            icon: 'fa-rectangle-list',
            title: 'Liskov Substitution Principle',
            tagline: 'Подтипы должны вести себя как базовый тип',
            summary: 'Объект подкласса должен заменять объект базового класса без нарушения корректности программы.',
            code: `// Нарушение LSP: Square не может быть Rectangle
class Rectangle {
    setWidth(w) { this.width = w; }
    setHeight(h) { this.height = h; }
    area() { return this.width * this.height; }
}
class Square extends Rectangle {
    setWidth(w) { this.width = this.height = w; }
    setHeight(h) { this.width = this.height = h; }
}
// Ожидаем 20, получаем 25
const rect = new Square();
rect.setWidth(5);
rect.setHeight(4);
console.log(rect.area()); // 16, не 20!`,
            bullets: [
                'Предусловия не могут усиливаться, постусловия не могут ослабляться.',
                'Инварианты родителя должны сохраняться.'
            ],
            why: 'Нарушение LSP приводит к неожиданному поведению при полиморфизме.',
            how: 'Проверяй контракты: что обещает базовый класс, должен выполнять наследник.',
            takeaway: 'LSP = гарантия безопасной замены типов.'
        },
        {
            icon: 'fa-puzzle-piece',
            title: 'Interface Segregation Principle',
            tagline: 'Клиенты не должны зависеть от неиспользуемых методов',
            summary: 'Лучше много специализированных интерфейсов, чем один универсальный.',
            code: `// Плохо: принтер зависит от методов, которые не использует
interface Machine {
    print(): void;
    scan(): void;
    fax(): void;
}

// Хорошо: разделяем ответственности
interface Printer { print(): void; }
interface Scanner { scan(): void; }
class SimplePrinter implements Printer {
    print() { /* ... */ }
}`,
            bullets: [
                'Толстые интерфейсы вынуждают реализовывать ненужное.',
                'Композиция интерфейсов лучше наследования.'
            ],
            why: 'Большие интерфейсы создают ложные зависимости и усложняют тесты.',
            how: 'Группируй методы по ролям использования, а не по объектам.',
            takeaway: 'ISP делает интерфейсы фокусными и переиспользуемыми.'
        }
    ],
    foundations: [
        {
            icon: 'fa-diagram-project',
            title: 'Cohesion vs Coupling',
            summary: 'Высокая связность внутри модуля и слабая между модулями — главный критерий архитектурной чистоты.',
            why: 'Случайное перемешивание обязанностей приводит к «мини-монолитам» и дорогому развитию.',
            how: 'Смотри на причины изменений: разные причины → разные модули.',
            takeaway: 'Cohesion — про скорость команды, Coupling — про стресс при релизах.'
        },
        {
            icon: 'fa-scale-balanced',
            title: 'Компромисс время/память',
            summary: 'Мемоизация, кэши, lookup-таблицы — всё это обмен памяти на скорость.',
            why: 'Нужно заранее планировать бюджет ресурсов, иначе оптимизация превратится в пожар.',
            how: 'Фиксируй SLA: сколько миллисекунд готов потратить, сколько мегабайт доступно.',
            takeaway: 'Хороший инженер объясняет, какой ресурс он покупает за счёт другого.'
        },
        {
            icon: 'fa-cubes',
            title: 'Модульность и барьеры абстракции',
            tagline: 'Границы ответственности',
            summary: 'Модуль должен иметь чёткую границу: публичный API и скрытую реализацию. Внешний мир знает только интерфейс.',
            code: `// Модуль с чёткой границей
export class UserService {
    private db: Database;
    private cache: Cache;
    
    async getUser(id: string): Promise<User> {
        // детали скрыты
    }
}
// Внутренности недоступны снаружи`,
            bullets: [
                'Публичный API = контракт, который стабилен.',
                'Приватная реализация может меняться без влияния на клиентов.'
            ],
            why: 'Без барьеров изменения распространяются волной по всей системе.',
            how: 'Экспортируй только необходимое. Скрывай детали через private, internal, модули.',
            takeaway: 'Модульность = изоляция изменений.'
        },
        {
            icon: 'fa-arrows-down-to-line',
            title: 'Принцип наименьшего знания (Law of Demeter)',
            tagline: 'Не разговаривай с незнакомцами',
            summary: 'Объект должен взаимодействовать только с непосредственными "друзьями", а не копаться в их внутренностях.',
            code: `// Плохо: цепочка вызовов
order.getCustomer().getAddress().getCity();

// Хорошо: делегирование
order.getCustomerCity();

// Или: спроси объект, а не данные
class Order {
    canShipTo(country: string): boolean {
        return this.customer.isInCountry(country);
    }
}`,
            bullets: [
                'Каждый . в цепочке — это зависимость от внутренней структуры.',
                'Tell, don\'t ask: приказывай объекту, а не вытаскивай данные.'
            ],
            why: 'Глубокие цепочки делают код хрупким к реструктуризации.',
            how: 'Если нужны данные из глубины, добавь метод в ближайший объект.',
            takeaway: 'LoD снижает связанность через ограничение области видимости.'
        },
        {
            icon: 'fa-sitemap',
            title: 'Слоистая архитектура',
            tagline: 'Разделение по уровням абстракции',
            summary: 'Система делится на слои: UI, бизнес-логика, доступ к данным. Каждый слой зависит только от нижележащих.',
            code: `// Слои не должны пересекаться
// UI -> Service -> Repository -> Database

class UserController {
    constructor(private userService: UserService) {}
    async getUser(req, res) {
        const user = await this.userService.findById(req.params.id);
        res.json(user);
    }
}

class UserService {
    constructor(private repo: UserRepository) {}
    async findById(id: string) {
        return this.repo.findById(id);
    }
}`,
            bullets: [
                'Вертикальное разделение: каждый слой знает только о соседнем ниже.',
                'Горизонтальное: модули внутри слоя независимы.'
            ],
            why: 'Слои изолируют изменения: замена базы данных не трогает UI.',
            how: 'Не импортируй из верхних слоёв в нижние. Используй dependency injection.',
            takeaway: 'Слоистая архитектура = управляемая сложность.'
        },
        {
            icon: 'fa-right-left',
            title: 'Иммутабельность как безопасность',
            tagline: 'Данные, которые нельзя сломать',
            summary: 'Неизменяемые структуры исключают класс багов: гонки, непредсказуемые мутации, сайд-эффекты.',
            code: `// Мутабельность — риск
const user = { name: 'Alice', age: 25 };
updateUser(user); // что внутри? поменяет ли user?

// Иммутабельность — безопасность
const updatedUser = { ...user, age: 26 };
// user остался прежним`,
            bullets: [
                'Immutable данные безопасны в многопоточности и React rendering.',
                'История изменений бесплатна: сохраняй старые версии.'
            ],
            why: 'Мутации — источник трудноотлавливаемых багов.',
            how: 'Используй readonly, Object.freeze, библиотеки (Immer, Immutable.js).',
            takeaway: 'Иммутабельность упрощает reasoning о коде.'
        },
        {
            icon: 'fa-ban',
            title: 'Fail fast принцип',
            tagline: 'Валидация на границах',
            summary: 'Проверяй инварианты при входе в систему. Падай громко и рано, а не тихо и поздно.',
            code: `function processPayment(amount: number) {
    if (amount <= 0) 
        throw new Error('Amount must be positive');
    if (amount > 1_000_000) 
        throw new Error('Amount exceeds limit');
    // дальше работаем с валидными данными
}`,
            bullets: [
                'Ранние проверки упрощают дебаг: стек указывает на источник проблемы.',
                'Валидация на границах: входы API, конструкторы, парсеры.'
            ],
            why: 'Тихие ошибки распространяются по системе, усложняя поиск причины.',
            how: 'Используй assert, guard clauses, типизацию для ранней проверки.',
            takeaway: 'Fail fast = быстрый фидбек о проблемах.'
        }
    ]
};

AppConfig.theory.global = globalTheoryInsights;
AppConfig.theory.byTab = theoryLibrary;

// Вопросы для тестов по вкладкам
AppConfig.questions = {
    oop: [
        {
            title: '1. Инкапсуляция и приватные поля',
            code: `class BankAccount {\n    private balance: number = 0;\n    \n    public deposit(amount: number): void {\n        this.balance += amount;\n    }\n    \n    public getBalance(): number {\n        return this.balance;\n    }\n}`,
            question: 'Что произойдет при попытке обратиться к balance напрямую?',
            answers: [
                { text: 'A) Ошибка компиляции TypeScript', correct: true },
                { text: 'B) Получим значение 0', correct: false },
                { text: 'C) Получим undefined', correct: false }
            ],
            explanation: 'Правильный ответ A. TypeScript не позволит скомпилировать код с доступом к private полю извне класса. В runtime JavaScript приватные поля (#balance) также недоступны, в отличие от convention-based подхода (_balance).'
        },
        {
            title: '2. Наследование',
            code: `class Animal {\n    protected name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    speak(): void {\n        console.log(\`${'${this.name}'} издает звук\`);\n    }\n}\nclass Dog extends Animal {\n    speak(): void {\n        console.log(\`${'${this.name}'} лает: Гав-гав!\`);\n    }\n}\nconst dog = new Dog('Рекс');\ndog.speak();`,
            answers: [
                { text: 'A) "Рекс издает звук"', correct: false },
                { text: 'B) "Рекс лает: Гав-гав!"', correct: true },
                { text: 'C) Ошибка (name недоступен)', correct: false }
            ],
            explanation: 'Правильный ответ B.\n\nПочему: Класс Dog переопределяет метод speak() родительского класса Animal. Когда мы вызываем dog.speak(), выполняется версия метода из класса Dog, а не из Animal. Поле name доступно, так как оно объявлено как protected в родительском классе.\n\nЗачем: Наследование позволяет создавать специализированные классы на основе общих, переиспользуя код и расширяя функциональность. Это ключевой принцип ООП, который помогает избежать дублирования кода и создавать иерархии классов с общим поведением.'
        },
        {
            title: '3. Полиморфизм',
            code: `class Shape {\n    area(): number {\n        return 0;\n    }\n}\nclass Circle extends Shape {\n    constructor(private radius: number) {\n        super();\n    }\n    area(): number {\n        return Math.PI * this.radius * this.radius;\n    }\n}\nclass Rectangle extends Shape {\n    constructor(private width: number, private height: number) {\n        super();\n    }\n    area(): number {\n        return this.width * this.height;\n    }\n}\nconst shapes: Shape[] = [new Circle(5), new Rectangle(4, 6)];\nshapes.forEach(shape => console.log(shape.area()));`,
            answers: [
                { text: 'A) 0, 0', correct: false },
                { text: 'B) ~78.54, 24', correct: true },
                { text: 'C) Ошибка типизации', correct: false }
            ],
            explanation: 'Правильный ответ B.\n\nПочему: Полиморфизм позволяет работать с объектами разных классов через общий интерфейс (базовый класс Shape). Массив shapes содержит объекты типа Circle и Rectangle, но TypeScript позволяет хранить их как Shape[], потому что оба класса наследуются от Shape. При вызове area() для каждого элемента выполняется соответствующая реализация метода: для Circle вычисляется площадь круга (π × 5² ≈ 78.54), для Rectangle — площадь прямоугольника (4 × 6 = 24).\n\nЗачем: Полиморфизм — это мощный инструмент для написания гибкого и расширяемого кода. Вы можете добавлять новые типы фигур (Triangle, Square и т.д.) без изменения кода, который работает с массивом shapes. Это соответствует принципу Open/Closed: код открыт для расширения, но закрыт для модификации.'
        },
        {
            title: '4. Абстракция',
            code: `abstract class Vehicle {\n    abstract start(): void;\n    abstract stop(): void;\n    protected move(): void {\n        console.log('Движется...');\n    }\n}\nclass Car extends Vehicle {\n    start(): void {\n        console.log('Заводим двигатель');\n        this.move();\n    }\n    stop(): void {\n        console.log('Останавливаем двигатель');\n    }\n}\nconst car = new Car();\ncar.start();`,
            answers: [
                { text: 'A) Ошибка компиляции', correct: false },
                { text: 'B) "Заводим двигатель" и "Движется..."', correct: true },
                { text: 'C) Ничего не выведется', correct: false }
            ],
            explanation: 'Правильный ответ B.\n\nПочему: Абстрактный класс Vehicle определяет контракт (абстрактные методы start и stop), который должны реализовать все наследники. Класс Car реализует метод start(), который выводит "Заводим двигатель" и затем вызывает защищенный метод move() из родительского класса, который выводит "Движется...". Абстрактные классы нельзя инстанцировать напрямую (new Vehicle() вызовет ошибку), но можно создавать экземпляры их конкретных реализаций.\n\nЗачем: Абстракция позволяет определить общий интерфейс для группы связанных классов, скрывая детали реализации. Это помогает создавать более понятную архитектуру: вы определяете "что должно быть сделано" в абстрактном классе, а "как это сделать" — в конкретных реализациях. Это упрощает поддержку кода и делает систему более гибкой.'
        },
        {
            title: '5. This в классах',
            code: `class Counter {\n    private count: number = 0;\n    increment(): void {\n        this.count++;\n    }\n    getCount = (): number => {\n        return this.count;\n    }\n    getCountRegular(): number {\n        return this.count;\n    }\n}\nconst counter = new Counter();\nconst getCountRef = counter.getCount;\nconst getCountRegularRef = counter.getCountRegular;\ncounter.increment();\nconsole.log(getCountRef());\nconsole.log(getCountRegularRef());`,
            answers: [
                { text: 'A) 1 и ошибка TypeError', correct: true },
                { text: 'B) 1 и 1', correct: false },
                { text: 'C) undefined и undefined', correct: false }
            ],
            explanation: 'Правильный ответ A. Стрелочная функция сохраняет контекст this из момента создания, а обычная функция теряет его при отрыве от объекта. В strict mode это приводит к TypeError.'
        },
        {
            title: '6. Геттеры и сеттеры',
            code: `class Temperature {\n    private _celsius: number = 0;\n    \n    get fahrenheit(): number {\n        return this._celsius * 9/5 + 32;\n    }\n    \n    set fahrenheit(value: number) {\n        this._celsius = (value - 32) * 5/9;\n    }\n}\nconst temp = new Temperature();\ntemp.fahrenheit = 212;\nconsole.log(temp.fahrenheit);`,
            question: 'Что выведет код?',
            answers: [
                { text: 'A) 212', correct: true },
                { text: 'B) 100', correct: false },
                { text: 'C) Ошибка типов', correct: false }
            ],
            explanation: 'Правильный ответ A. Сеттер конвертирует 212°F в 100°C и сохраняет в _celsius. Геттер затем конвертирует обратно: 100°C = 212°F. Геттеры/сеттеры позволяют контролировать доступ к данным с дополнительной логикой.'
        },
        {
            title: '7. Статические методы',
            code: `class MathUtils {\n    static PI = 3.14159;\n    \n    static circleArea(radius: number): number {\n        return this.PI * radius * radius;\n    }\n}\nconst utils = new MathUtils();\nconsole.log(utils.circleArea(5));`,
            question: 'Что произойдет?',
            answers: [
                { text: 'A) Ошибка компиляции', correct: true },
                { text: 'B) 78.53975', correct: false },
                { text: 'C) undefined', correct: false }
            ],
            explanation: 'Правильный ответ A. Статические методы принадлежат классу, а не экземпляру. Правильный вызов: MathUtils.circleArea(5). Статика полезна для utility-функций, которые не зависят от состояния экземпляра.'
        },
        {
            title: '8. Readonly свойства',
            code: `class User {\n    readonly id: string;\n    name: string;\n    \n    constructor(id: string, name: string) {\n        this.id = id;\n        this.name = name;\n    }\n    \n    updateId(newId: string) {\n        this.id = newId;\n    }\n}\nconst user = new User('123', 'Alice');\nuser.updateId('456');`,
            question: 'Что произойдет?',
            answers: [
                { text: 'A) Ошибка: нельзя изменить readonly поле', correct: true },
                { text: 'B) id успешно обновится', correct: false },
                { text: 'C) Ошибка только в runtime', correct: false }
            ],
            explanation: 'Правильный ответ A. Readonly поля можно инициализировать только в конструкторе. После этого их нельзя изменить даже внутри методов класса. Это обеспечивает иммутабельность ключевых свойств.'
        }
    ],
    algorithms: [
        {
            title: '1. Бинарный поиск',
            code: `function binarySearch(arr: number[], target: number): number {\n    let left = 0;\n    let right = arr.length - 1;\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (arr[mid] === target) return mid;\n        if (arr[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\nconsole.log(binarySearch([1,3,5,7,9,11],7));`,
            answers: [
                { text: 'A) 3, O(log n)', correct: true },
                { text: 'B) 7, O(n)', correct: false },
                { text: 'C) -1, O(n log n)', correct: false }
            ],
            explanation: 'Правильный ответ A. Бинарный поиск делит область поиска пополам на каждой итерации, находя элемент за O(log n). Для миллиона элементов потребуется ~20 операций вместо миллиона при линейном поиске.'
        },
        {
            title: '2. Два указателя',
            code: `function isPalindrome(s: string): boolean {\n    let left = 0, right = s.length - 1;\n    while (left < right) {\n        if (s[left] !== s[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\nconsole.log(isPalindrome('radar'));`,
            question: 'Какая сложность по времени и памяти?',
            answers: [
                { text: 'A) O(n) время, O(1) память', correct: true },
                { text: 'B) O(n²) время, O(n) память', correct: false },
                { text: 'C) O(log n) время, O(1) память', correct: false }
            ],
            explanation: 'Правильный ответ A. Паттерн "два указателя" проходит строку один раз (O(n)), используя только две переменные для индексов. Это эффективнее реверса строки, который требует O(n) памяти.'
        },
        {
            title: '3. Скользящее окно',
            code: `function maxSumSubarray(arr: number[], k: number): number {\n    let maxSum = 0, windowSum = 0;\n    for (let i = 0; i < k; i++) windowSum += arr[i];\n    maxSum = windowSum;\n    for (let i = k; i < arr.length; i++) {\n        windowSum += arr[i] - arr[i - k];\n        maxSum = Math.max(maxSum, windowSum);\n    }\n    return maxSum;\n}`,
            question: 'Почему это эффективнее наивного подхода?',
            answers: [
                { text: 'A) O(n) вместо O(n*k), используем предыдущие вычисления', correct: true },
                { text: 'B) Используем меньше памяти', correct: false },
                { text: 'C) Работает только для положительных чисел', correct: false }
            ],
            explanation: 'Правильный ответ A. Вместо пересчета суммы каждого окна с нуля (O(n*k)), мы вычитаем уходящий элемент и добавляем входящий (O(n)). Для k=1000 и n=10000 это дает ускорение в 1000 раз.'
        },
        {
            title: '4. Быстрая сортировка',
            code: `function quickSort(arr: number[]): number[] {\n    if (arr.length <= 1) return arr;\n    const pivot = arr[0];\n    const left = arr.slice(1).filter(x => x <= pivot);\n    const right = arr.slice(1).filter(x => x > pivot);\n    return [...quickSort(left), pivot, ...quickSort(right)];\n}`,
            question: 'Какая сложность в худшем случае?',
            answers: [
                { text: 'A) O(n²) если массив уже отсортирован', correct: true },
                { text: 'B) Всегда O(n log n)', correct: false },
                { text: 'C) O(n) для малых массивов', correct: false }
            ],
            explanation: 'Правильный ответ A. Если выбирать первый элемент как pivot в отсортированном массиве, получаем несбалансированное разделение. Решение: случайный pivot или медиана трех элементов для O(n log n) в среднем.'
        },
        {
            title: '5. Мемоизация',
            code: `function fib(n: number, memo: Map<number,number> = new Map()): number {\n    if (n <= 1) return n;\n    if (memo.has(n)) return memo.get(n)!;\n    const result = fib(n-1, memo) + fib(n-2, memo);\n    memo.set(n, result);\n    return result;\n}`,
            question: 'Как изменилась сложность по сравнению с наивной рекурсией?',
            answers: [
                { text: 'A) С O(2ⁿ) до O(n), храним результаты подзадач', correct: true },
                { text: 'B) С O(n²) до O(n log n)', correct: false },
                { text: 'C) Память O(1) вместо O(n)', correct: false }
            ],
            explanation: 'Правильный ответ A. Без мемоизации fib(5) вызывает fib(4) и fib(3), которые снова вызывают одни и те же функции. С кешем каждое значение вычисляется один раз. fib(40) без кеша — секунды, с кешем — мгновенно.'
        },
        {
            title: '6. Жадный алгоритм',
            code: `function coinChange(amount: number, coins: number[]): number {\n    coins.sort((a,b) => b - a);\n    let count = 0;\n    for (const coin of coins) {\n        count += Math.floor(amount / coin);\n        amount %= coin;\n    }\n    return amount === 0 ? count : -1;\n}`,
            question: 'Когда жадный алгоритм даст неоптимальный результат?',
            answers: [
                { text: 'A) Монеты [1,3,4], сумма 6: даст 4+1+1 вместо 3+3', correct: true },
                { text: 'B) Всегда даст оптимум', correct: false },
                { text: 'C) Только для простых чисел', correct: false }
            ],
            explanation: 'Правильный ответ A. Жадный подход работает для "канонических" систем (как [1,5,10,25]), но не для произвольных наборов. Для гарантированно оптимального решения нужно динамическое программирование.'
        },
        {
            title: '7. Поиск в глубину (DFS)',
            code: `function dfs(node: TreeNode | null): number {\n    if (!node) return 0;\n    const left = dfs(node.left);\n    const right = dfs(node.right);\n    return Math.max(left, right) + 1;\n}`,
            question: 'Что вычисляет эта функция?',
            answers: [
                { text: 'A) Высоту дерева', correct: true },
                { text: 'B) Количество узлов', correct: false },
                { text: 'C) Сумму значений', correct: false }
            ],
            explanation: 'Правильный ответ A. DFS рекурсивно находит максимальную глубину среди поддеревьев и добавляет 1 за текущий уровень. Паттерн DFS подходит для любых задач обхода дерева: валидация, поиск пути, подсчет узлов.'
        },
        {
            title: '8. Сложность алгоритмов',
            code: `for (let i = 0; i < n; i++) {\n    for (let j = i; j < n; j++) {\n        console.log(i, j);\n    }\n}`,
            question: 'Какая временная сложность?',
            answers: [
                { text: 'A) O(n²) — итераций n + (n-1) + ... + 1 = n(n+1)/2', correct: true },
                { text: 'B) O(n) — внутренний цикл уменьшается', correct: false },
                { text: 'C) O(n log n) — делим диапазон', correct: false }
            ],
            explanation: 'Правильный ответ A. Хотя внутренний цикл начинается с i, общее количество итераций — арифметическая прогрессия, которая дает O(n²). Константа 1/2 отбрасывается в Big-O нотации.'
        }
    ],
    'data-structures': [
        {
            title: '1. Стек vs Очередь',
            code: `const stack = [];\nstack.push(1); stack.push(2); stack.push(3);\nconsole.log(stack.pop());\n\nconst queue = [];\nqueue.push(1); queue.push(2); queue.push(3);\nconsole.log(queue.shift());`,
            question: 'Что выведет код?',
            answers: [
                { text: 'A) 3 и 1 (LIFO vs FIFO)', correct: true },
                { text: 'B) 1 и 1', correct: false },
                { text: 'C) 3 и 3', correct: false }
            ],
            explanation: 'Правильный ответ A. Стек работает как стопка тарелок (Last In First Out), очередь — как очередь в магазине (First In First Out). Стек для отмены действий, очередь для задач по порядку.'
        },
        {
            title: '2. Map vs Object',
            code: `const obj = { '1': 'one', '2': 'two' };\nconst map = new Map([[1, 'one'], [2, 'two']]);\nconsole.log(obj[1]);\nconsole.log(map.get(1));`,
            question: 'В чем ключевое различие?',
            answers: [
                { text: 'A) Ключи объекта всегда строки, Map сохраняет тип', correct: true },
                { text: 'B) Map быстрее для малых данных', correct: false },
                { text: 'C) Object нельзя итерировать', correct: false }
            ],
            explanation: 'Правильный ответ A. obj[1] === "one" потому что 1 конвертируется в "1". Map хранит числовой ключ. Map также сохраняет порядок вставки и имеет удобные методы .size, .has(), .delete().'
        },
        {
            title: '3. Set для уникальности',
            code: `const arr = [1, 2, 2, 3, 3, 3, 4];\nconst unique = [...new Set(arr)];\nconsole.log(unique.length);`,
            question: 'Какая сложность удаления дубликатов?',
            answers: [
                { text: 'A) O(n) — Set проверяет наличие за O(1)', correct: true },
                { text: 'B) O(n²) — нужно сравнивать каждый с каждым', correct: false },
                { text: 'C) O(n log n) — требуется сортировка', correct: false }
            ],
            explanation: 'Правильный ответ A. Set использует хеш-таблицу внутри, добавление и проверка за O(1). Альтернатива через filter: arr.filter((v,i,a) => a.indexOf(v) === i) — O(n²) из-за indexOf.'
        },
        {
            title: '4. Связный список',
            code: `class Node {\n    constructor(val) {\n        this.val = val;\n        this.next = null;\n    }\n}\nconst head = new Node(1);\nhead.next = new Node(2);\nhead.next.next = new Node(3);`,
            question: 'Когда связный список лучше массива?',
            answers: [
                { text: 'A) Частые вставки/удаления в начале O(1) vs O(n)', correct: true },
                { text: 'B) Быстрый доступ по индексу', correct: false },
                { text: 'C) Меньше памяти', correct: false }
            ],
            explanation: 'Правильный ответ A. Вставка в начало списка: создать узел и переставить указатель. В массиве нужно сдвинуть все элементы. Но доступ к i-му элементу: список O(n), массив O(1).'
        },
        {
            title: '5. Бинарное дерево поиска',
            code: `class BST {\n    constructor(val) {\n        this.val = val;\n        this.left = this.right = null;\n    }\n    insert(val) {\n        if (val < this.val) {\n            if (!this.left) this.left = new BST(val);\n            else this.left.insert(val);\n        } else {\n            if (!this.right) this.right = new BST(val);\n            else this.right.insert(val);\n        }\n    }\n}`,
            question: 'Какое преимущество BST перед несортированным массивом?',
            answers: [
                { text: 'A) Поиск O(log n) в сбалансированном дереве', correct: true },
                { text: 'B) Всегда O(1) доступ', correct: false },
                { text: 'C) Меньше используется памяти', correct: false }
            ],
            explanation: 'Правильный ответ A. В сбалансированном BST каждое сравнение отсекает половину элементов. Но если вставлять отсортированные данные (1,2,3...), дерево вырождается в список — нужна самобалансировка (AVL, Red-Black).'
        },
        {
            title: '6. Heap (куча)',
            code: `class MinHeap {\n    constructor() { this.heap = []; }\n    insert(val) {\n        this.heap.push(val);\n        this.bubbleUp(this.heap.length - 1);\n    }\n    extractMin() {\n        const min = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this.bubbleDown(0);\n        return min;\n    }\n}`,
            question: 'Для чего используется heap?',
            answers: [
                { text: 'A) Приоритетные очереди, получение min/max за O(1)', correct: true },
                { text: 'B) Быстрая сортировка', correct: false },
                { text: 'C) Хранение уникальных элементов', correct: false }
            ],
            explanation: 'Правильный ответ A. Min-heap гарантирует, что наименьший элемент всегда на вершине. Вставка и извлечение за O(log n). Используется в алгоритме Дейкстры, планировщиках задач, сортировке (heapsort).'
        },
        {
            title: '7. Граф: представление',
            code: `// Список смежности\nconst graph = {\n    A: ['B', 'C'],\n    B: ['A', 'D'],\n    C: ['A', 'D'],\n    D: ['B', 'C']\n};\n\n// Матрица смежности\nconst matrix = [\n    [0, 1, 1, 0],\n    [1, 0, 0, 1],\n    [1, 0, 0, 1],\n    [0, 1, 1, 0]\n];`,
            question: 'Когда использовать список вместо матрицы?',
            answers: [
                { text: 'A) Для разреженных графов (мало ребер): экономия памяти', correct: true },
                { text: 'B) Список всегда быстрее', correct: false },
                { text: 'C) Матрица не поддерживает веса', correct: false }
            ],
            explanation: 'Правильный ответ A. Матрица требует O(V²) памяти, список — O(V+E). Для социальной сети (миллионы пользователей, но у каждого ~100 друзей) список эффективнее. Матрица удобна для плотных графов и быстрой проверки наличия ребра.'
        },
        {
            title: '8. Trie (префиксное дерево)',
            code: `class TrieNode {\n    constructor() {\n        this.children = {};\n        this.isEndOfWord = false;\n    }\n}\nclass Trie {\n    constructor() { this.root = new TrieNode(); }\n    insert(word) {\n        let node = this.root;\n        for (const char of word) {\n            if (!node.children[char]) node.children[char] = new TrieNode();\n            node = node.children[char];\n        }\n        node.isEndOfWord = true;\n    }\n}`,
            question: 'Зачем нужен Trie?',
            answers: [
                { text: 'A) Автодополнение, поиск слов с префиксом за O(k)', correct: true },
                { text: 'B) Сортировка строк', correct: false },
                { text: 'C) Сжатие данных', correct: false }
            ],
            explanation: 'Правильный ответ A. Trie хранит общие префиксы один раз. Поиск "hello" проходит 5 узлов независимо от количества слов в словаре. Используется в поисковых подсказках, проверке орфографии, IP-маршрутизации.'
        }
    ],
    'leetcode': [
        {
            title: '1. Two Sum — хеш-таблица',
            code: `function twoSum(nums: number[], target: number): number[] {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) return [map.get(complement), i];\n        map.set(nums[i], i);\n    }\n    return [];\n}`,
            question: 'Почему это O(n), а не O(n²)?',
            answers: [
                { text: 'A) Один проход массива, Map.has() за O(1)', correct: true },
                { text: 'B) Используем сортировку', correct: false },
                { text: 'C) Рекурсия оптимизирована', correct: false }
            ],
            explanation: 'Правильный ответ A. Вместо вложенных циклов (каждый элемент сравнивается со всеми), храним в Map уже просмотренные числа. Для каждого элемента за O(1) проверяем, есть ли нужная пара.'
        },
        {
            title: '2. Valid Parentheses — стек',
            code: `function isValid(s: string): boolean {\n    const stack = [];\n    const pairs = { ')': '(', '}': '{', ']': '[' };\n    for (const char of s) {\n        if (char in pairs) {\n            if (stack.pop() !== pairs[char]) return false;\n        } else stack.push(char);\n    }\n    return stack.length === 0;\n}`,
            question: 'Почему стек идеален для этой задачи?',
            answers: [
                { text: 'A) LIFO структура соответствует вложенности скобок', correct: true },
                { text: 'B) Экономит память', correct: false },
                { text: 'C) Работает за O(log n)', correct: false }
            ],
            explanation: 'Правильный ответ A. Последняя открытая скобка должна закрыться первой — это LIFO (Last In First Out). При встрече закрывающей скобки проверяем, соответствует ли она верхней открывающей в стеке.'
        },
        {
            title: '3. Merge Sorted Arrays',
            code: `function merge(nums1: number[], m: number, nums2: number[], n: number): void {\n    let i = m - 1, j = n - 1, k = m + n - 1;\n    while (j >= 0) {\n        if (i >= 0 && nums1[i] > nums2[j]) nums1[k--] = nums1[i--];\n        else nums1[k--] = nums2[j--];\n    }\n}`,
            question: 'Почему заполняем с конца?',
            answers: [
                { text: 'A) Избегаем перезаписи элементов nums1, не нужна доп. память', correct: true },
                { text: 'B) Так быстрее работает', correct: false },
                { text: 'C) Требование задачи', correct: false }
            ],
            explanation: 'Правильный ответ A. nums1 имеет достаточно места в конце. Если заполнять с начала, придется сдвигать элементы или использовать O(m+n) памяти. Заполнение с конца — O(1) памяти.'
        },
        {
            title: '4. Binary Tree Level Order',
            code: `function levelOrder(root: TreeNode | null): number[][] {\n    if (!root) return [];\n    const result = [], queue = [root];\n    while (queue.length) {\n        const level = [];\n        const size = queue.length;\n        for (let i = 0; i < size; i++) {\n            const node = queue.shift()!;\n            level.push(node.val);\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        result.push(level);\n    }\n    return result;\n}`,
            question: 'Зачем фиксируем size перед циклом?',
            answers: [
                { text: 'A) Чтобы обработать только узлы текущего уровня', correct: true },
                { text: 'B) Оптимизация производительности', correct: false },
                { text: 'C) Избежать бесконечного цикла', correct: false }
            ],
            explanation: 'Правильный ответ A. Без фиксации size мы бы добавляли дочерние узлы в queue во время обработки и не смогли бы разделить уровни. size = количество узлов на текущем уровне.'
        },
        {
            title: '5. Longest Substring Without Repeating',
            code: `function lengthOfLongestSubstring(s: string): number {\n    const set = new Set();\n    let left = 0, max = 0;\n    for (let right = 0; right < s.length; right++) {\n        while (set.has(s[right])) {\n            set.delete(s[left]);\n            left++;\n        }\n        set.add(s[right]);\n        max = Math.max(max, right - left + 1);\n    }\n    return max;\n}`,
            question: 'Какой паттерн используется?',
            answers: [
                { text: 'A) Скользящее окно с изменяемым размером', correct: true },
                { text: 'B) Два указателя на отсортированном массиве', correct: false },
                { text: 'C) Динамическое программирование', correct: false }
            ],
            explanation: 'Правильный ответ A. Окно [left, right] растет вправо и сжимается слева при нахождении дубликата. Set отслеживает уникальность символов в текущем окне за O(1).'
        },
        {
            title: '6. Container With Most Water',
            code: `function maxArea(height: number[]): number {\n    let left = 0, right = height.length - 1;\n    let max = 0;\n    while (left < right) {\n        const area = Math.min(height[left], height[right]) * (right - left);\n        max = Math.max(max, area);\n        if (height[left] < height[right]) left++;\n        else right--;\n    }\n    return max;\n}`,
            question: 'Почему двигаем указатель с меньшей высотой?',
            answers: [
                { text: 'A) Площадь ограничена минимумом, двигая больший — точно не улучшим', correct: true },
                { text: 'B) Так быстрее сходится', correct: false },
                { text: 'C) Случайная эвристика', correct: false }
            ],
            explanation: 'Правильный ответ A. Площадь = min(height[left], height[right]) × width. Если двигаем указатель с большей высотой, ширина уменьшится, а высота не может вырасти (ограничена другой стороной). Двигаем меньший — есть шанс найти выше.'
        },
        {
            title: '7. Climbing Stairs — DP',
            code: `function climbStairs(n: number): number {\n    if (n <= 2) return n;\n    let prev1 = 2, prev2 = 1;\n    for (let i = 3; i <= n; i++) {\n        const current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n    return prev1;\n}`,
            question: 'Почему current = prev1 + prev2?',
            answers: [
                { text: 'A) На ступень n можно прийти с n-1 или n-2', correct: true },
                { text: 'B) Это формула Фибоначчи', correct: false },
                { text: 'C) Эмпирическая закономерность', correct: false }
            ],
            explanation: 'Правильный ответ A. Чтобы попасть на ступень n, можно сделать шаг с (n-1) или (n-2). Количество способов = сумма способов для этих двух позиций. Действительно похоже на Фибоначчи, но важно понимать логику.'
        },
        {
            title: '8. Product of Array Except Self',
            code: `function productExceptSelf(nums: number[]): number[] {\n    const result = Array(nums.length).fill(1);\n    let left = 1;\n    for (let i = 0; i < nums.length; i++) {\n        result[i] = left;\n        left *= nums[i];\n    }\n    let right = 1;\n    for (let i = nums.length - 1; i >= 0; i--) {\n        result[i] *= right;\n        right *= nums[i];\n    }\n    return result;\n}`,
            question: 'Как избежали деления и O(n) памяти?',
            answers: [
                { text: 'A) Два прохода: накапливаем произведения слева и справа', correct: true },
                { text: 'B) Используем битовые операции', correct: false },
                { text: 'C) Специальная математическая формула', correct: false }
            ],
            explanation: 'Правильный ответ A. Первый проход: result[i] = произведение всех слева. Второй: умножаем на произведение справа. Результат: произведение всех кроме i-го. Без деления (важно для нулей) и без доп. массивов.'
        }
    ],
    'event-loop': [
        {
            title: '1. Порядок выполнения',
            question: 'В каком порядке выполнится код?',
            code: `console.log('A');\nsetTimeout(() => console.log('B'), 0);\nconsole.log('C');`,
            answers: [
                { text: 'A, B, C', correct: false },
                { text: 'A, C, B', correct: true },
                { text: 'B, A, C', correct: false }
            ],
            explanation: 'Правильный ответ A, C, B. Синхронный код выполняется первым (A, C), затем event loop берёт макрозадачу setTimeout (B). Даже с задержкой 0мс, setTimeout не может выполниться раньше синхронного кода.'
        },
        {
            title: '2. Микрозадачи vs макрозадачи',
            code: `console.log('1');\nsetTimeout(() => console.log('2'), 0);\nPromise.resolve().then(() => console.log('3'));\nconsole.log('4');`,
            question: 'Что выведется?',
            answers: [
                { text: '1, 4, 3, 2', correct: true },
                { text: '1, 2, 3, 4', correct: false },
                { text: '1, 4, 2, 3', correct: false }
            ],
            explanation: 'Правильный ответ 1, 4, 3, 2. Сначала весь синхронный код (1, 4), затем все микрозадачи (Promise — 3), затем макрозадачи (setTimeout — 2). Микрозадачи имеют приоритет над макрозадачами.'
        },
        {
            title: '3. Promise chain',
            code: `Promise.resolve()\n  .then(() => console.log('A'))\n  .then(() => console.log('B'));\nPromise.resolve()\n  .then(() => console.log('C'))\n  .then(() => console.log('D'));\nconsole.log('E');`,
            question: 'Порядок вывода?',
            answers: [
                { text: 'E, A, C, B, D', correct: true },
                { text: 'A, B, C, D, E', correct: false },
                { text: 'E, A, B, C, D', correct: false }
            ],
            explanation: 'Правильный ответ E, A, C, B, D. Синхронный код E первым. Затем первые then обоих промисов (A, C) в порядке создания. Потом вторые then (B, D). Каждый then создаёт новую микрозадачу.'
        },
        {
            title: '4. Async/await',
            code: `async function test() {\n    console.log('1');\n    await Promise.resolve();\n    console.log('2');\n}\ntest();\nconsole.log('3');`,
            question: 'Что выведется?',
            answers: [
                { text: '1, 3, 2', correct: true },
                { text: '1, 2, 3', correct: false },
                { text: '3, 1, 2', correct: false }
            ],
            explanation: 'Правильный ответ 1, 3, 2. Функция test выполняется до await (1), затем await возвращает управление в event loop. Синхронный код продолжается (3). После завершения синхронного кода выполняется код после await (2) как микрозадача.'
        },
        {
            title: '5. SetTimeout vs setImmediate',
            code: `setTimeout(() => console.log('timeout'), 0);\nsetImmediate(() => console.log('immediate'));`,
            question: 'В Node.js что выполнится первым?',
            answers: [
                { text: 'Зависит от контекста выполнения', correct: true },
                { text: 'Всегда timeout', correct: false },
                { text: 'Всегда immediate', correct: false }
            ],
            explanation: 'Правильный ответ: зависит от контекста. В главном модуле порядок недетерминирован (зависит от производительности). Внутри I/O цикла setImmediate всегда первым. В браузерах setImmediate нет.'
        },
        {
            title: '6. Бесконечный цикл',
            code: `while (true) {\n    console.log('loop');\n}\nconsole.log('after');`,
            question: 'Что произойдёт?',
            answers: [
                { text: 'UI зависнет, after никогда не выведется', correct: true },
                { text: 'after выведется после нескольких итераций', correct: false },
                { text: 'Браузер автоматически прервёт цикл', correct: false }
            ],
            explanation: 'Правильный ответ: UI зависнет. Синхронный бесконечный цикл блокирует event loop, не давая обработать другие задачи. Браузер заморозится, пользователь не сможет взаимодействовать с страницей.'
        },
        {
            title: '7. RequestAnimationFrame',
            code: `setTimeout(() => console.log('timeout'), 0);\nrequestAnimationFrame(() => console.log('raf'));\nPromise.resolve().then(() => console.log('promise'));`,
            question: 'Порядок выполнения?',
            answers: [
                { text: 'promise, raf, timeout', correct: true },
                { text: 'timeout, raf, promise', correct: false },
                { text: 'raf, promise, timeout', correct: false }
            ],
            explanation: 'Правильный ответ: promise, raf, timeout. Микрозадачи (promise) выполняются первыми. rAF вызывается перед отрисовкой кадра, но после микрозадач. setTimeout — макрозадача, выполняется в следующем тике event loop.'
        },
        {
            title: '8. Process.nextTick (Node.js)',
            code: `Promise.resolve().then(() => console.log('promise'));\nprocess.nextTick(() => console.log('nextTick'));\nconsole.log('sync');`,
            question: 'Что выведется в Node.js?',
            answers: [
                { text: 'sync, nextTick, promise', correct: true },
                { text: 'sync, promise, nextTick', correct: false },
                { text: 'nextTick, sync, promise', correct: false }
            ],
            explanation: 'Правильный ответ: sync, nextTick, promise. Синхронный код первым. process.nextTick имеет наивысший приоритет среди асинхронных операций и выполняется до микрозадач (promise). Затем идут обычные микрозадачи.'
        }
    ],
    'solid': [
        {
            title: '1. Single Responsibility Principle',
            code: `class User {\n    constructor(public name: string, public email: string) {}\n    save() {\n        // сохранение в БД\n    }\n    sendEmail(message: string) {\n        // отправка email\n    }\n    generateReport() {\n        // генерация отчёта\n    }\n}`,
            question: 'Что нарушает SRP в этом классе?',
            answers: [
                { text: 'Класс имеет три причины для изменения: БД, email, отчёты', correct: true },
                { text: 'Слишком много методов', correct: false },
                { text: 'Используются публичные поля', correct: false }
            ],
            explanation: 'Правильный ответ A. SRP: класс должен иметь одну причину для изменения. User отвечает за данные пользователя, персистентность, email и отчёты — разные обязанности. Нужно разделить на UserRepository, EmailService, ReportGenerator.'
        },
        {
            title: '2. Open/Closed Principle',
            code: `class PaymentProcessor {\n    process(type: string, amount: number) {\n        if (type === 'card') { /* логика карты */ }\n        else if (type === 'paypal') { /* логика PayPal */ }\n        else if (type === 'crypto') { /* логика крипты */ }\n    }\n}`,
            question: 'Почему это нарушает OCP?',
            answers: [
                { text: 'Добавление нового способа оплаты требует модификации класса', correct: true },
                { text: 'Используется if-else вместо switch', correct: false },
                { text: 'Нет обработки ошибок', correct: false }
            ],
            explanation: 'Правильный ответ A. OCP: открыт для расширения, закрыт для модификации. Каждый новый тип платежа требует изменения process(). Решение: интерфейс PaymentMethod с реализациями CardPayment, PayPalPayment, и полиморфизм.'
        },
        {
            title: '3. Liskov Substitution Principle',
            code: `class Bird {\n    fly() { console.log('Flying'); }\n}\nclass Penguin extends Bird {\n    fly() { throw new Error('Cannot fly'); }\n}`,
            question: 'Как нарушен LSP?',
            answers: [
                { text: 'Penguin не может заменить Bird без нарушения поведения', correct: true },
                { text: 'Penguin должен переопределить все методы', correct: false },
                { text: 'Bird должен быть абстрактным классом', correct: false }
            ],
            explanation: 'Правильный ответ A. LSP: подтипы должны заменять базовый тип без нарушений. Код, ожидающий Bird, сломается на Penguin. Решение: не все птицы летают — разделить на FlyingBird и Bird, или использовать композицию (добавить способность летать).'
        },
        {
            title: '4. Interface Segregation Principle',
            code: `interface Worker {\n    work(): void;\n    eat(): void;\n    sleep(): void;\n}\nclass Robot implements Worker {\n    work() { /* работа */ }\n    eat() { throw new Error('Robots dont eat'); }\n    sleep() { throw new Error('Robots dont sleep'); }\n}`,
            question: 'В чём проблема с ISP?',
            answers: [
                { text: 'Robot вынужден реализовывать неиспользуемые методы', correct: true },
                { text: 'Worker должен быть классом', correct: false },
                { text: 'Робот не может быть Worker', correct: false }
            ],
            explanation: 'Правильный ответ A. ISP: клиенты не должны зависеть от неиспользуемых методов. Разделить на Workable, Eatable, Sleepable интерфейсы. Robot implements только Workable. Человек implements все три.'
        },
        {
            title: '5. Dependency Inversion Principle',
            code: `class MySQLDatabase {\n    save(data: any) { /* MySQL логика */ }\n}\nclass UserService {\n    private db = new MySQLDatabase();\n    createUser(user) {\n        this.db.save(user);\n    }\n}`,
            question: 'Что нарушает DIP?',
            answers: [
                { text: 'UserService зависит от конкретной реализации БД', correct: true },
                { text: 'Не используется async/await', correct: false },
                { text: 'db должен быть публичным', correct: false }
            ],
            explanation: 'Правильный ответ A. DIP: зависеть от абстракций, а не конкретики. UserService жёстко привязан к MySQL. Решение: interface Database { save(data): void }, внедрение через конструктор. Так можно легко заменить на PostgreSQL или мок в тестах.'
        },
        {
            title: '6. SOLID в реальном коде',
            code: `interface Storage { get(key: string): any; set(key: string, val: any): void; }\nclass LocalStorage implements Storage { /* ... */ }\nclass SessionStorage implements Storage { /* ... */ }\nclass Cache {\n    constructor(private storage: Storage) {}\n    fetch(key: string) { return this.storage.get(key); }\n}`,
            question: 'Какие принципы SOLID применены?',
            answers: [
                { text: 'DIP (зависимость от абстракции) и OCP (расширяемость)', correct: true },
                { text: 'Только SRP', correct: false },
                { text: 'ISP и LSP', correct: false }
            ],
            explanation: 'Правильный ответ A. DIP: Cache зависит от интерфейса Storage, не конкретной реализации. OCP: можно добавлять новые Storage без изменения Cache. Также видны элементы ISP (минималистичный интерфейс) и LSP (любой Storage заменяем).'
        },
        {
            title: '7. Выявление нарушений',
            code: `class OrderService {\n    processOrder(order) {\n        // валидация\n        // скидки\n        // оплата\n        // отправка email\n        // обновление склада\n        // логирование\n    }\n}`,
            question: 'Какой принцип нарушен больше всего?',
            answers: [
                { text: 'SRP — слишком много обязанностей', correct: true },
                { text: 'OCP — нельзя расширить', correct: false },
                { text: 'DIP — нет зависимостей', correct: false }
            ],
            explanation: 'Правильный ответ A. Явное нарушение SRP: класс делает всё от валидации до логирования. Каждое изменение требований (новый тип скидки, другой email-провайдер) затрагивает этот класс. Нужно разделить на специализированные сервисы.'
        },
        {
            title: '8. Рефакторинг под SOLID',
            question: 'Как правильно применить SOLID при рефакторинге?',
            answers: [
                { text: 'Постепенно: выделить интерфейсы, разбить обязанности, внедрить DI', correct: true },
                { text: 'Переписать всё с нуля по всем принципам сразу', correct: false },
                { text: 'Сначала написать все тесты, потом рефакторить', correct: false }
            ],
            explanation: 'Правильный ответ A. Рефакторинг должен быть пошаговым и безопасным. Начни с выделения интерфейсов (DIP), потом раздели обязанности (SRP), добавь точки расширения (OCP). Тесты помогают, но не обязательно писать их все заранее. Большой bang-рефакторинг рискован.'
        }
    ],
    'foundations': [
        {
            title: '1. Cohesion vs Coupling',
            code: `// Низкая cohesion: разные обязанности\nclass Utils {\n    formatDate() {}\n    sendEmail() {}\n    calculateTax() {}\n}\n\n// Высокая cohesion: одна обязанность\nclass DateFormatter {\n    format() {}\n    parse() {}\n    validate() {}\n}`,
            question: 'Почему высокая cohesion лучше?',
            answers: [
                { text: 'Методы связаны одной целью, легче понимать и менять', correct: true },
                { text: 'Меньше классов в проекте', correct: false },
                { text: 'Быстрее работает', correct: false }
            ],
            explanation: 'Правильный ответ A. Высокая cohesion = методы класса работают над одной задачей. Изменения локализованы, легче тестировать. Utils с разными обязанностями = низкая cohesion, хаотичные изменения.'
        },
        {
            title: '2. Coupling',
            code: `// Тесная связанность (tight coupling)\nclass OrderService {\n    process() {\n        const db = new MySQLDatabase();\n        db.save();\n    }\n}\n\n// Слабая связанность (loose coupling)\nclass OrderService {\n    constructor(private db: Database) {}\n    process() { this.db.save(); }\n}`,
            question: 'Преимущество loose coupling?',
            answers: [
                { text: 'Легко заменить зависимости, проще тестировать', correct: true },
                { text: 'Меньше кода', correct: false },
                { text: 'Быстрее компилируется', correct: false }
            ],
            explanation: 'Правильный ответ A. Loose coupling через интерфейсы и DI позволяет менять реализации без изменения кода. Tight coupling жёстко привязывает к конкретной реализации, усложняя тесты и замену компонентов.'
        },
        {
            title: '3. Law of Demeter',
            code: `// Нарушение: цепочка вызовов\nuser.getWallet().getBalance().getAmount();\n\n// Соблюдение: делегирование\nuser.getWalletAmount();`,
            question: 'Зачем нужен Law of Demeter?',
            answers: [
                { text: 'Уменьшает зависимость от внутренней структуры', correct: true },
                { text: 'Сокращает количество методов', correct: false },
                { text: 'Увеличивает скорость', correct: false }
            ],
            explanation: 'Правильный ответ A. LoD: объект должен общаться только с "соседями", не копаться в их внутренностях. Цепочки делают код хрупким — изменение Wallet.getBalance() сломает все места использования.'
        },
        {
            title: '4. Immutability',
            code: `const mutable = { count: 0 };\nfunction increment(obj) {\n    obj.count++; // мутация\n}\n\nconst immutable = { count: 0 };\nfunction increment(obj) {\n    return { ...obj, count: obj.count + 1 }; // новый объект\n}`,
            question: 'Преимущество иммутабельности?',
            answers: [
                { text: 'Предсказуемость, безопасность в многопоточности', correct: true },
                { text: 'Меньше памяти', correct: false },
                { text: 'Быстрее выполняется', correct: false }
            ],
            explanation: 'Правильный ответ A. Иммутабельные данные нельзя случайно изменить, они безопасны для передачи между функциями и потоками. React использует иммутабельность для эффективного re-rendering. Минус: больше объектов, но часто компенсируется structural sharing.'
        },
        {
            title: '5. Модульность',
            question: 'Что делает модуль хорошим?',
            answers: [
                { text: 'Чёткий API, скрытая реализация, одна ответственность', correct: true },
                { text: 'Большой размер кода', correct: false },
                { text: 'Много экспортов', correct: false }
            ],
            explanation: 'Правильный ответ A. Хороший модуль = минимальный публичный API, максимум скрытых деталей, одна область ответственности. Изменения внутри не влияют на внешний код. Плохой модуль: утечки абстракций, множество зависимостей.'
        },
        {
            title: '6. Fail Fast',
            code: `// Плохо: тихая ошибка\nfunction divide(a, b) {\n    return a / b; // b=0 даст Infinity\n}\n\n// Хорошо: fail fast\nfunction divide(a, b) {\n    if (b === 0) throw new Error('Division by zero');\n    return a / b;\n}`,
            question: 'Зачем fail fast?',
            answers: [
                { text: 'Ранняя ошибка упрощает дебаг, показывая источник проблемы', correct: true },
                { text: 'Программа работает быстрее', correct: false },
                { text: 'Нужно меньше кода', correct: false }
            ],
            explanation: 'Правильный ответ A. Fail fast: падай громко и рано, а не тихо и поздно. Тихая ошибка (Infinity) распространится по системе, затрудняя поиск причины. Ранний throw сразу указывает на source of truth.'
        },
        {
            title: '7. Layered Architecture',
            question: 'Главное правило слоистой архитектуры?',
            answers: [
                { text: 'Каждый слой зависит только от нижележащих', correct: true },
                { text: 'Все слои могут общаться друг с другом', correct: false },
                { text: 'Слоёв должно быть ровно три', correct: false }
            ],
            explanation: 'Правильный ответ A. Слои: UI → Service → Repository → Database. Верхние зависят от нижних, но не наоборот. Это изолирует изменения: замена БД не влияет на UI. Нарушение = спагетти-код.'
        },
        {
            title: '8. Time-Memory Tradeoff',
            code: `// Время за память: мемоизация\nconst cache = new Map();\nfunction fib(n) {\n    if (cache.has(n)) return cache.get(n);\n    const result = n <= 1 ? n : fib(n-1) + fib(n-2);\n    cache.set(n, result);\n    return result;\n}`,
            question: 'Что мы получаем?',
            answers: [
                { text: 'Ускорение с O(2ⁿ) до O(n), но используем O(n) памяти', correct: true },
                { text: 'Экономим память', correct: false },
                { text: 'Уменьшаем сложность до O(log n)', correct: false }
            ],
            explanation: 'Правильный ответ A. Классический tradeoff: жертвуем памятью ради скорости. Без кеша fib(40) — секунды, с кешем — мгновенно. Каждое значение вычисляется один раз. Другие примеры: индексы БД, CDN, lookup tables.'
        }
    ],
    'theory': [
        {
            title: '1. CAP теорема',
            question: 'Что утверждает CAP теорема?',
            answers: [
                { text: 'Можно гарантировать только 2 из 3: Consistency, Availability, Partition tolerance', correct: true },
                { text: 'Можно гарантировать все три свойства', correct: false },
                { text: 'Нужно выбрать одно свойство', correct: false }
            ],
            explanation: 'Правильный ответ A. В распределённой системе при разделении сети (P) нужно выбирать между доступностью (A) и согласованностью (C). CP системы (PostgreSQL) жертвуют доступностью. AP системы (Cassandra) — согласованностью.'
        },
        {
            title: '2. Eventual Consistency',
            question: 'Что означает eventual consistency?',
            answers: [
                { text: 'Данные станут согласованными со временем, но не мгновенно', correct: true },
                { text: 'Данные всегда согласованы', correct: false },
                { text: 'Данные никогда не станут согласованными', correct: false }
            ],
            explanation: 'Правильный ответ A. Eventual consistency: после прекращения обновлений все реплики придут к одному состоянию. Используется в AP системах (Amazon DynamoDB). Trade-off: высокая доступность против мгновенной согласованности.'
        },
        {
            title: '3. ACID vs BASE',
            question: 'В чём разница между ACID и BASE?',
            answers: [
                { text: 'ACID: строгая согласованность, BASE: eventual consistency', correct: true },
                { text: 'ACID для NoSQL, BASE для SQL', correct: false },
                { text: 'Это синонимы', correct: false }
            ],
            explanation: 'Правильный ответ A. ACID (Atomicity, Consistency, Isolation, Durability) — строгие гарантии транзакций. BASE (Basically Available, Soft state, Eventually consistent) — мягкие гарантии для масштабируемости. ACID для банков, BASE для соцсетей.'
        },
        {
            title: '4. Идемпотентность',
            question: 'Что значит идемпотентная операция?',
            answers: [
                { text: 'Повторные вызовы дают тот же результат', correct: true },
                { text: 'Операция выполняется быстро', correct: false },
                { text: 'Операция не требует параметров', correct: false }
            ],
            explanation: 'Правильный ответ A. Идемпотентность: f(f(x)) = f(x). GET запросы идемпотентны (читать дважды = читать раз), POST — нет (создаст два ресурса). PUT и DELETE идемпотентны. Важно для retry-логики и надёжности распределённых систем.'
        },
        {
            title: '5. Optimistic vs Pessimistic Locking',
            question: 'Когда использовать optimistic locking?',
            answers: [
                { text: 'Редкие конфликты, высокая конкурентность', correct: true },
                { text: 'Частые конфликты', correct: false },
                { text: 'Только в однопоточных приложениях', correct: false }
            ],
            explanation: 'Правильный ответ A. Optimistic: читаем без блокировки, при записи проверяем версию. Если изменили — retry. Pessimistic: блокируем на чтение. Optimistic для читающих нагрузок, pessimistic — для частых конфликтов записи.'
        },
        {
            title: '6. Микросервисы vs Монолит',
            question: 'Главное преимущество микросервисов?',
            answers: [
                { text: 'Независимое развёртывание и масштабирование сервисов', correct: true },
                { text: 'Проще разрабатывать', correct: false },
                { text: 'Меньше кода', correct: false }
            ],
            explanation: 'Правильный ответ A. Микросервисы: изолированные сервисы с независимыми деплоями. Плюсы: масштабируемость, fault isolation, выбор технологий. Минусы: сложность сети, транзакций, мониторинга. Монолит проще для старта, микросервисы для зрелых продуктов.'
        },
        {
            title: '7. DRY принцип',
            question: 'Когда нарушение DRY оправдано?',
            answers: [
                { text: 'Случайное совпадение, разные причины изменений', correct: true },
                { text: 'Никогда', correct: false },
                { text: 'Всегда, если код короче', correct: false }
            ],
            explanation: 'Правильный ответ A. DRY (Don\'t Repeat Yourself) про знания, не про код. Два похожих куска могут меняться по разным причинам. Преждевременная абстракция хуже дублирования. "Дублирование дешевле, чем неправильная абстракция" (Sandi Metz).'
        },
        {
            title: '8. Tech Debt',
            question: 'Как правильно управлять техдолгом?',
            answers: [
                { text: 'Балансировать фичи и рефакторинг, документировать решения', correct: true },
                { text: 'Игнорировать до кризиса', correct: false },
                { text: 'Рефакторить всё сразу', correct: false }
            ],
            explanation: 'Правильный ответ A. Tech debt неизбежен. Стратегия: выделять время на рефакторинг (20% спринта), документировать компромиссы (ADR), приоритизировать критичный долг. Игнорирование ведёт к "банкротству" проекта, big bang рефакторинг — к остановке фич.'
        }
    ]
};

const COMPLETION_STORAGE_KEY = 'cs-prep.completedTabs';

// Мотивирующие цитаты в зависимости от процента правильных ответов
const motivationalQuotes = {
    excellent: [
        { text: "Превосходно! Ты настоящий мастер!", icon: "fa-rocket" },
        { text: "Невероятно! Твои знания на высшем уровне!", icon: "fa-star" },
        { text: "Отличная работа! Ты готов к любому собеседованию!", icon: "fa-trophy" }
    ],
    good: [
        { text: "Хорошая работа! Продолжай в том же духе!", icon: "fa-lightbulb" },
        { text: "Ты на правильном пути! Еще немного практики и будет идеально!", icon: "fa-book" },
        { text: "Отлично! Ты уже многого достиг!", icon: "fa-fire" }
    ],
    average: [
        { text: "Неплохо! Каждая ошибка - это шаг к совершенству!", icon: "fa-graduation-cap" },
        { text: "Продолжай учиться! Успех приходит с практикой!", icon: "fa-dumbbell" },
        { text: "Ты движешься в правильном направлении! Не сдавайся!", icon: "fa-bullseye" }
    ],
    needsImprovement: [
        { text: "Не расстраивайся! Каждый эксперт когда-то был новичком!", icon: "fa-seedling" },
        { text: "Продолжай практиковаться! Ты обязательно достигнешь цели!", icon: "fa-book-open" },
        { text: "Верь в себя! С каждым днем ты становишься лучше!", icon: "fa-star-half-alt" }
    ]
};

// Состояние приложения: хранит текущую вкладку, индексы вопросов и счетчики правильных ответов
const appState = {
    currentTab: 'oop',
    currentQuestionIndex: {}, // Индекс текущего вопроса для каждой вкладки
    correctAnswers: {}, // Количество правильных ответов для каждой вкладки
    completedTabs: loadCompletedTabs()
};

function loadCompletedTabs() {
    try {
        const raw = localStorage.getItem(COMPLETION_STORAGE_KEY);
        return raw ? JSON.parse(raw) : {};
    } catch (error) {
        console.warn('Не удалось загрузить статус тем:', error);
        return {};
    }
}

function saveCompletedTabs() {
    try {
        localStorage.setItem(COMPLETION_STORAGE_KEY, JSON.stringify(appState.completedTabs));
    } catch (error) {
        console.warn('Не удалось сохранить статус тем:', error);
    }
}

function isTabCompleted(tabId) {
    return Boolean(appState.completedTabs && appState.completedTabs[tabId]);
}

function markTabCompleted(tabId, payload = {}) {
    appState.completedTabs[tabId] = {
        completedAt: new Date().toISOString(),
        ...payload
    };
    saveCompletedTabs();
    updateTabCompletionIndicators();
    updateHeroCompletionBadge(tabId);
}

function updateTabCompletionIndicators() {
    const buttons = document.querySelectorAll('.tab-btn');
    buttons.forEach((btn) => {
        const tabId = btn.getAttribute('data-tab');
        const statusEl = btn.querySelector('.tab-status');
        const completed = isTabCompleted(tabId);
        btn.classList.toggle('tab-btn-completed', completed);
        if (statusEl) {
            statusEl.innerHTML = completed
                ? '<i class="fas fa-check-circle"></i> Пройдено'
                : '<i class="fas fa-book-open"></i> Теория + практика';
        }
    });
}

function updateHeroCompletionBadge(tabId) {
    const pill = document.querySelector(`.hero-progress-pill[data-hero-status="${tabId}"]`);
    if (!pill) return;
    const defaultLabel = pill.dataset.defaultLabel || 'Теория → Практика → Результат';
    if (isTabCompleted(tabId)) {
        pill.classList.add('completed');
        pill.innerHTML = '<i class="fas fa-check-circle"></i> Тема пройдена на 100%';
    } else {
        pill.classList.remove('completed');
        pill.innerHTML = `<i class="fas fa-book-reader"></i> ${defaultLabel}`;
    }
}

function scrollPracticeIntoView() {
    const practicePanel = document.querySelector('.practice-panel');
    if (!practicePanel) return;
    const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    practicePanel.scrollIntoView({ behavior: prefersReduced ? 'auto' : 'smooth', block: 'start' });
}
